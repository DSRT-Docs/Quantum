#!/usr/bin/env python3
# DSRT Library Binding Generator
# Generates bindings for external languages

import os
import sys
import json
from typing import Dict, List, Any
import argparse

class BindingGenerator:
    """Generator for language bindings"""
    
    def __init__(self):
        self.config = {}
        self.output_dir = "Generated"
        
    def load_config(self, config_path: str):
        """Load configuration file"""
        with open(config_path, 'r') as f:
            self.config = json.load(f)
            
    def generate_csharp(self, api_data: Dict[str, Any]):
        """Generate C# bindings"""
        output = []
        output.append("// Auto-generated C# bindings for DSRT Library")
        output.append("// Generated by gen_bindings.py")
        output.append("")
        output.append("using System;")
        output.append("using System.Runtime.InteropServices;")
        output.append("")
        output.append("namespace DSRT")
        output.append("{")
        output.append("    public static class NativeMethods")
        output.append("    {")
        
        # Generate method declarations
        for func in api_data.get("functions", []):
            csharp_sig = self._to_csharp_signature(func)
            output.append(f"        {csharp_sig}")
            
        output.append("    }")
        output.append("}")
        
        return "\n".join(output)
    
    def generate_python(self, api_data: Dict[str, Any]):
        """Generate Python bindings"""
        output = []
        output.append("#!/usr/bin/env python3")
        output.append("# Auto-generated Python bindings for DSRT Library")
        output.append("# Generated by gen_bindings.py")
        output.append("")
        output.append("import ctypes")
        output.append("import os")
        output.append("")
        output.append("class DSRTLibrary:")
        output.append("    \"\"\"DSRT Library Python bindings\"\"\"")
        output.append("    ")
        output.append("    def __init__(self, lib_path=None):")
        output.append("        if lib_path is None:")
        output.append("            if os.name == 'nt':")
        output.append("                lib_path = 'DSRTLibrary.dll'")
        output.append("            elif os.name == 'posix':")
        output.append("                lib_path = 'libDSRTLibrary.so'")
        output.append("            else:")
        output.append("                lib_path = 'DSRTLibrary'")
        output.append("        ")
        output.append("        self._lib = ctypes.CDLL(lib_path)")
        output.append("        self._setup_functions()")
        output.append("    ")
        output.append("    def _setup_functions(self):")
        
        # Generate function setups
        for func in api_data.get("functions", []):
            py_setup = self._to_python_setup(func)
            output.append(f"        {py_setup}")
            
        output.append("")
        
        # Generate wrapper methods
        for func in api_data.get("functions", []):
            py_wrapper = self._to_python_wrapper(func)
            output.append(f"    {py_wrapper}")
            output.append("")
            
        return "\n".join(output)
    
    def _to_csharp_signature(self, func: Dict[str, Any]) -> str:
        """Convert function to C# signature"""
        name = func["name"]
        ret_type = self._map_type_csharp(func.get("return_type", "void"))
        params = []
        
        for param in func.get("parameters", []):
            param_type = self._map_type_csharp(param["type"])
            param_name = param["name"]
            params.append(f"{param_type} {param_name}")
            
        param_str = ", ".join(params)
        dll_import = f'[DllImport("DSRTLibrary", CallingConvention = CallingConvention.Cdecl)]'
        
        return f"{dll_import}\n        public static extern {ret_type} {name}({param_str});"
    
    def _to_python_setup(self, func: Dict[str, Any]) -> str:
        """Convert function to Python setup"""
        name = func["name"]
        ret_type = self._map_type_python(func.get("return_type", "void"))
        
        return f"self.{name} = self._lib.{name}\n        self.{name}.restype = {ret_type}"
    
    def _to_python_wrapper(self, func: Dict[str, Any]) -> str:
        """Convert function to Python wrapper"""
        name = func["name"]
        params = []
        
        for param in func.get("parameters", []):
            params.append(param["name"])
            
        param_str = ", ".join(["self"] + params)
        docstring = func.get("description", "Auto-generated function")
        
        wrapper = f"def {name}({param_str}):\n"
        wrapper += f'        """{docstring}"""\n'
        
        # Generate call
        if params:
            call_params = ", ".join(params)
            wrapper += f"        return self.{name}({call_params})"
        else:
            wrapper += f"        return self.{name}()"
            
        return wrapper
    
    def _map_type_csharp(self, c_type: str) -> str:
        """Map C type to C# type"""
        type_map = {
            "void": "void",
            "int": "int",
            "float": "float",
            "double": "double",
            "bool": "bool",
            "char*": "string",
            "const char*": "string"
        }
        return type_map.get(c_type, "IntPtr")
    
    def _map_type_python(self, c_type: str) -> str:
        """Map C type to Python ctypes"""
        type_map = {
            "void": "None",
            "int": "ctypes.c_int",
            "float": "ctypes.c_float",
            "double": "ctypes.c_double",
            "bool": "ctypes.c_bool",
            "char*": "ctypes.c_char_p",
            "const char*": "ctypes.c_char_p"
        }
        return type_map.get(c_type, "ctypes.c_void_p")
    
    def generate_all(self, api_file: str):
        """Generate all bindings"""
        # Load API definition
        with open(api_file, 'r') as f:
            api_data = json.load(f)
        
        # Create output directory
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Generate C# bindings
        csharp_code = self.generate_csharp(api_data)
        with open(os.path.join(self.output_dir, "DSRTCSharp.cs"), 'w') as f:
            f.write(csharp_code)
            
        # Generate Python bindings
        python_code = self.generate_python(api_data)
        with open(os.path.join(self.output_dir, "dsrt_python.py"), 'w') as f:
            f.write(python_code)
            
        print(f"Generated bindings in {self.output_dir}/")

def main():
    """Main function"""
    parser = argparse.ArgumentParser(description="Generate language bindings for DSRT Library")
    parser.add_argument("--api", required=True, help="API definition JSON file")
    parser.add_argument("--config", help="Generator configuration file")
    parser.add_argument("--output", default="Generated", help="Output directory")
    
    args = parser.parse_args()
    
    generator = BindingGenerator()
    generator.output_dir = args.output
    
    if args.config:
        generator.load_config(args.config)
    
    generator.generate_all(args.api)
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
